Compare And Swap      
 CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。
 这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：
                     首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。
                     最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，
      CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。（这段描述引自《Java并发编程实践》）
       简单的来说，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，
       它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。
       下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。

       
	1. public final int incrementAndGet() {  
	2.     for (;;) {  
	3.         int current = get();  
	4.         int next = current + 1;  
	5.         if (compareAndSet(current, next)) //比较and set 否则循环继续。  
	6.             return next;  
	7.     }  
	8. }  

       
  
  
  
  ABA问题是一种异常现象：如果在算法中的节点可以被循环使用，那么在使用“比较并交换”指令时就可能出现这个问题（如果在没有垃圾回收机制的环境 中）。在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作。在大多数情况下，这种判断是足够的。然而，有时候还需要知道 “自从上次看到V的值为A以来，这个值是否发生了变化？”在某些算法中，如果V值首先由A编程B,在由B编程A，那么仍然被认为发生了变化，并需要重新执 行算法中的某些步骤。
 
如果在算法中采用自己的方式来管理节点对象的内存，那么可能出现ABA问题。在这种情况下，即使链表的头结点仍然只想之前观察到的节点，那么也不足 以说明链表的内容没有发生变化。
如果通过垃圾回收器来管理链表节点仍然无法避免ABA问题，那么还有一个相对简单的解决方法：不是只是更新某个引用的值， 而是更新两个值，包含一个引用和一个版本号。即使这个值由A变成B
，然后又变为A，版本号也将是不同的。AtomicStampedReference以 及AtomicMarkableReference支持在两个变量上执行原子的条件更新。
AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，
从而避免ABA问题。类似地，AtomicMarkableReference将更新一个“对象引用—- 布尔值”二元组，
在某些算法中将通过这种二元组使节点保存在链表中同时又将其标记为“已删除节点”。
     